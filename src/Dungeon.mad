import type { Maybe } from "Maybe"

import type { Area, BoundingBox } from "./Area"
import type { Seed } from "./LCG"
import type { TileMap } from "./Tile"

import Dictionary from "Dictionary"
import Float from "Float"
import Fn from "Function"
import IO from "IO"
import Integer from "Integer"
import Int from "Integer"
import List from "List"
import Math from "Math"
import { Just, Nothing, fromMaybe, isJust } from "Maybe"
import Number from "Number"
import String from "String"
import Terminal from "Terminal"

import {
  Area,
  Box,
  anyAreaContainsPoint,
  anyAreaIntersectsArea,
  areaContainsPoint,
  areaIntersectsArea,
  getBoundingBox,
} from "./Area"
import LCG from "./LCG"
import { makeOdd, minimum } from "./Math"
import { hex } from "./String"
import { makeTileMap, renderTile } from "./Tile"



export type Dungeon = Dungeon(Seed, Integer, Integer, TileMap, List Area)

boundByStageWithDefault :: Integer -> Integer -> Integer -> Integer
export boundByStageWithDefault = (edge, minima, dimension) => Math.min(minima, dimension - edge)

boundByStage :: Integer -> Integer -> Integer
export boundByStage = boundByStageWithDefault(4)

randomPoint :: Integer -> Integer -> Seed -> Integer
randomPoint = (max, size, seed) => pipe(
  Math.floor,
  Float.toInteger,
  LCG.toInt(0, $, seed),
  (r) => r * 2 + 1,
  Fn.when((v) => v + size > max, () => Math.max(1, max - size - 1)),
)((max - size) / 2)

calcRoomSize :: Integer -> Integer -> Integer -> Integer -> Seed -> Integer
calcRoomSize = (size, rectangularity, maximum, edgeDistance, seed) => Float.toInteger(
  Math.round(
    LCG.toFloat(seed) * Int.toFloat(Math.min(maximum - edgeDistance, size + rectangularity)),
  )
    + 1,
)

makeRandomRoom :: Integer -> Integer -> Integer -> Seed -> Area
makeRandomRoom = (stageWidth, stageHeight, pad, seed) => {
  size = LCG.toInt(1, 3 + pad, seed) * 2 + 1
  seed2 = LCG.next(seed)
  rect = LCG.toInt(0, 1 + Float.toInteger(Math.floor(size / 2) + 1), seed2) * 2
  seed3 = LCG.stepN(2, seed)
  isHotdog = LCG.toBool(seed3)
  seed4 = LCG.stepN(3, seed)
  width = calcRoomSize(size, isHotdog ? 0 : rect, stageWidth, 4, seed4)
  seed5 = LCG.stepN(4, seed)
  height = calcRoomSize(size, !isHotdog ? 0 : rect, stageHeight, 4, seed5)
  seed6 = LCG.stepN(5, seed)
  x = randomPoint(stageWidth, width, seed6)
  seed7 = LCG.stepN(6, seed)
  y = randomPoint(stageHeight, height, seed7)
  area = Area(x, y, width, height)
  return area
}

makeRooms :: Integer -> Integer -> Integer -> Integer -> Seed -> List Area
makeRooms = (total, stageWidth, stageHeight, pad, seed) => pipe(
  LCG.iterate($, makeRandomRoom(stageWidth, stageHeight, pad), seed),
  List.reduce((agg, x) => { return !anyAreaIntersectsArea(agg, x) ? [...agg, x] : agg }, []),
)(total)

BLUE_HASH = Terminal.text.blue("#")
GREEN_HASH = Terminal.text.green("#")
RED_HASH = Terminal.text.red("#")
YELLOW_HASH = Terminal.text.yellow("#")
WHITE_HASH = Terminal.text.white("#")



renderBoundary :: (String -> String) -> Integer -> String
renderBoundary = (fn, i) => pipe(
  hex,
  fn,
)(i)



render :: Dungeon -> String
export render = pipe(
  where {
    Dungeon(_, w, h, tiles, areas) =>
      pipe(
        List.reduce(
          (agg, rows) => List.append(
            pipe(
              map(renderTile(w, h, areas)),
              String.join(""),
            )(rows),
            agg,
          ),
          [],
        ),
        String.join(RED_HASH ++ "\n"),
        (r) => r
            ++ RED_HASH
            ++ "\n"
            ++ pipe(
              List.range(0),
              map(Fn.always(RED_HASH)),
              String.join(""),
            )(h)
            ++ RED_HASH,
      )(tiles)
  },
)

createDungeon :: Integer -> Integer -> Integer -> Dungeon
export createDungeon = (_seed, _width, _height) => {
  IO.trace("SEED", _seed)
  seed = LCG.mkSeed(_seed)
  min5 = minimum(5)
  stageDim = pipe(
    min5,
    makeOdd,
  )
  width = stageDim(_width)
  height = stageDim(_height)
  tiles = makeTileMap(height, width)
  areas = makeRooms(100, width, height, 3, seed)
  IO.trace("ROOMS", areas)
  return Dungeon(seed, width, height, tiles, areas)
}

createHiddenSeedDungeon :: Integer -> Integer -> Dungeon
export createHiddenSeedDungeon = (_width, _height) => pipe(
  LCG.mkSeedFromString,
  LCG.toInt(0, 1000000000000),
  createDungeon($, _width, _height),
)("dungeonaire@0.0.1")
