import type { Seed } from "./LCG"

import List from "List"
import Math from "Math"
import Number from "Number"

import LCG from "./LCG"



export type TileType = TileWall | TileFloor | TileDoor | TileHazard | TileVoid

// type x y
export type Tile = Tile(TileType, Float, Float)

// x y width height
export type Area = Room(Float, Float, Float, Float) | Stage(Float, Float, Float, Float)

// top right bottom left
export type BoundingBox = Box(Float, Float, Float, Float)

getBoundingBox :: Area -> BoundingBox
export getBoundingBox = (room) => where(room) {
  Room(x, y, w, h) =>
    Box(y, x + w - 1.0, y + h - 1.0, x)

  Stage(x, y, w, h) =>
    Box(y, x + w - 1.0, y + h - 1.0, x)
}

areaContainsPoint :: Area -> Float -> Float -> Boolean
export areaContainsPoint = (room, x, y) => pipe(
  getBoundingBox,
  where {
    Box(t, r, b, l) =>
      !(x < l || x > r || y < t || y > b)
  },
)(room)

areaIntersectsArea :: Area -> Area -> Boolean
export areaIntersectsArea = (j, k) => pipe(
  map(getBoundingBox),
  where {
    [Box(t, r, b, l), Box(t2, r2, b2, l2)] =>
      !(l2 > r || r2 < l || t2 > b || b2 < t)

    _ =>
      false
  },
)([j, k])

type Dungeon = Dungeon(Seed, Float, Float, List Tile)

minimum :: Float -> Float -> Float
minimum = (m, x) => x < m ? m : x

isEven :: Float -> Boolean
export isEven = (x) => Math.mod(Number.floatToInteger(x), 2) == 0

makeOdd :: Float -> Float
export makeOdd = (x) => isEven(x) ? x + 1.0 : x

alias Neighbors = {
  e :: Float,
  n :: Float,
  ne :: Float,
  nw :: Float,
  s :: Float,
  se :: Float,
  sw :: Float,
  w :: Float,
}

alias TileMap = List (List Tile)

getNeighbors :: TileMap -> Float -> Float -> {}
getNeighbors = (tiles, x, y) => {}

createDungeon :: String -> Float -> Float -> Dungeon
export createDungeon = (_seed, _width, _height) => {
  seed = LCG.mkSeedFromString(_seed)
  min5 = minimum(5.0)
  stageDim = pipe(
    min5,
    makeOdd,
  )
  width = stageDim(_width)
  height = stageDim(_height)
  return Dungeon(seed, width, height, [])
}
