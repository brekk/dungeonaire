import type { Area } from "./Area"
import type { Seed } from "./LCG"
import type { TileMap } from "./Tile"

import Float from "Float"
import Fn from "Function"
import IO from "IO"
import Integer from "Integer"
import Int from "Integer"
import List from "List"
import Math from "Math"

import { Area, anyAreaIntersectsArea } from "./Area"
import LCG from "./LCG"
import { makeOdd, minimum } from "./Math"
import { makeTileMap } from "./Tile"



export type Dungeon = Dungeon(Seed, Integer, Integer, TileMap, List Area)

boundByStageWithDefault :: Integer -> Integer -> Integer -> Integer
export boundByStageWithDefault = (edge, minima, dimension) => Math.min(minima, dimension - edge)

boundByStage :: Integer -> Integer -> Integer
export boundByStage = boundByStageWithDefault(4)

randomPoint :: Integer -> Integer -> Seed -> Integer
randomPoint = (max, size, seed) => pipe(
  Math.floor,
  Float.toInteger,
  LCG.toInt(0, $, seed),
  (r) => r * 2 + 1,
  Fn.when((v) => v + size > max, () => Math.max(1, max - size - 1)),
)((max - size) / 2)

calcRoomSize :: Integer -> Integer -> Integer -> Integer -> Seed -> Integer
calcRoomSize = (size, rectangularity, maximum, edgeDistance, seed) => Float.toInteger(
  Math.round(
    LCG.toFloat(seed) * Int.toFloat(Math.min(maximum - edgeDistance, size + rectangularity)),
  )
    + 1,
)

makeRandomRoom :: Integer -> Integer -> Integer -> Seed -> Area
makeRandomRoom = (stageWidth, stageHeight, pad, seed) => {
  size = LCG.toInt(1, 3 + pad, seed) * 2 + 1
  seed2 = LCG.next(seed)
  rect = LCG.toInt(0, 1 + Float.toInteger(Math.floor(size / 2) + 1), seed2) * 2
  seed3 = LCG.stepN(2, seed)
  isHotdog = LCG.toBool(seed3)
  seed4 = LCG.stepN(3, seed)
  width = calcRoomSize(size, isHotdog ? 0 : rect, stageWidth, 4, seed4)
  seed5 = LCG.stepN(4, seed)
  height = calcRoomSize(size, !isHotdog ? 0 : rect, stageHeight, 4, seed5)
  seed6 = LCG.stepN(5, seed)
  x = randomPoint(stageWidth, width, seed6)
  seed7 = LCG.stepN(6, seed)
  y = randomPoint(stageHeight, height, seed7)
  area = Area(x, y, width, height)
  return area
}

makeRooms :: Integer -> Integer -> Integer -> Integer -> Seed -> List Area
makeRooms = (total, stageWidth, stageHeight, pad, seed) => pipe(
  LCG.iterate($, makeRandomRoom(stageWidth, stageHeight, pad), seed),
  List.reduce((agg, x) => !anyAreaIntersectsArea(agg, x) ? [...agg, x] : agg, []),
)(total)

createDungeon :: Seed -> Integer -> Integer -> Dungeon
export createDungeon = (seed, _width, _height) => {
  IO.trace("SEED", seed)
  min5 = minimum(5)
  stageDim = pipe(
    min5,
    makeOdd,
  )
  width = stageDim(_width)
  height = stageDim(_height)
  tiles = makeTileMap(height, width)
  areas = makeRooms(100, width, height, 3, seed)
  IO.trace("ROOMS", areas)
  return Dungeon(seed, width, height, tiles, areas)
}
